#version 450
#extension GL_GOOGLE_include_directive : require
#include "defines.glsl"
#include "trace.glsl"
#include "utils.glsl"

layout(binding=0, outputFormat) uniform image2DArray rayOutput;

const uint threadCount = 64;
layout(local_size_x = threadCount, local_size_y = 1, local_size_z = 1) in;

layout(binding=4, std140) readonly buffer ShadowRays {
	RayPayload shadowRays[];
};

layout(binding=8, std140) readonly buffer PositionBuffer {
	vec3 positions[];
};

layout(binding=5, std140) readonly buffer Counters {
	uint shadowCounter;
	uint reflrectionCounter;
};

//Handling intersection

void main() {

	uint threadId = gl_GlobalInvocationID.x;

	if(threadId >= shadowCounter)
		return;

	const uint shadowId = threadId;

	const RayPayload payload = shadowRays[shadowId];

	const uvec2 loc = uvec2(payload.screenCoord >> 16, payload.screenCoord & 0xFFFF);
	const uvec2 size = uvec2(imageSize(rayOutput));

	//Shoot ray

	const Ray ray = Ray(
		vec4(positions[to1D(loc, size)], 1),
		vec4(decompressNormal(payload.dir), 1)
	);

	//TODO: Reason for the artifacts is probably the end distance.
	//		how do I solve it? Attenuation shouldn't be taken into account 

	if(traceOcclusion(ray, payload.maxDist))
		return;

	//Store

	#ifdef AVOID_CONFLICTS

		int layer = int(payload.flagLayer & 0xFFFF);

		vec3 color = payload.color;

		if(layer == 0)
			color += imageLoad(rayOutput, ivec3(loc, 0)).rgb;

		imageStore(rayOutput, ivec3(loc, layer), vec4(color, 0));

	#else
		const vec3 color = payload.color + imageLoad(rayOutput, ivec3(loc, 0)).rgb;
		imageStore(rayOutput, ivec3(loc, 0), vec4(color, 0));
	#endif
}