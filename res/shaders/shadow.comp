#version 450
#extension GL_GOOGLE_include_directive : require
#include "defines.glsl"
#include "trace.glsl"
#include "utils.glsl"

layout(binding=0, outputFormat) uniform image2DArray rayOutput;

layout(local_size_x = THREADS, local_size_y = 1, local_size_z = 1) in;

layout(binding=4, std140) readonly buffer ShadowRays {
	RayPayload shadowRays[];
};

layout(binding=8, std140) readonly buffer PositionBuffer {
	vec3 positions[];
};

layout(binding=5, std140) readonly buffer Counters {
	uint shadowCounter;
	uint reflrectionCounter;
};

//Handling intersection

void main() {

	uint threadId = gl_GlobalInvocationID.x;

	if(threadId >= shadowCounter)
		return;

	const uint shadowId = threadId;

	const RayPayload payload = shadowRays[shadowId];

	const uvec2 loc = uvec2(payload.screenCoord >> 16, payload.screenCoord & 0xFFFF);
	const uvec2 size = uvec2(imageSize(rayOutput));

	//Shoot ray
	
	const uint loc1D = loc.x + loc.y * size.x;
	const Ray ray = Ray(
		positions[loc1D], 0,
		payload.dir, 0
	);

	//TODO: Reason for the artifacts is probably the end distance.
	//		how do I solve it? Attenuation shouldn't be taken into account 

	if(traceOcclusion(ray, payload.maxDist))
		return;

	//Store

	const int layer = int(payload.color.y & 0xFFFF);

	const vec3 pcolor = vec3(unpackHalf2x16(payload.color.x), unpackHalf2x16(payload.color.y).y);

	#ifdef AVOID_CONFLICTS

		vec3 color = pcolor;

		if(layer == 0)
			color += imageLoad(rayOutput, ivec3(loc, 0)).rgb;

		imageStore(rayOutput, ivec3(loc, layer), vec4(pcolor, 0));

	#else
		const vec3 color = pcolor + imageLoad(rayOutput, ivec3(loc, 0)).rgb;
		imageStore(rayOutput, ivec3(loc, 0), vec4(color, 0));
	#endif
}