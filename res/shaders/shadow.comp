#version 450
#extension GL_GOOGLE_include_directive : require
#extension GL_ARB_shader_ballot : require
#extension GL_ARB_gpu_shader_int64 : require
#include "defines.glsl"
#include "trace.glsl"
#include "utils.glsl"

layout(local_size_x = THREADS, local_size_y = 1, local_size_z = 1) in;

layout(binding=4, std140) readonly buffer ShadowRays {
	ShadowPayload shadowRays[];
};

layout(binding=8, std140) readonly buffer PositionBuffer {
	vec3 positions[];
};

layout(binding=5, std140) readonly buffer Counters {
	uint shadowCounter;
	uint reflrectionCounter;
};

layout(binding=11, std140) writeonly buffer ShadowOutput {
	uint shadowOutput[];
};

//Handling intersection

void main() {

	uint shadowId = gl_GlobalInvocationID.x;

	if(shadowId >= shadowCounter)
		return;

	const ShadowPayload payload = shadowRays[shadowId];

	//Shoot rays for this warp
	
	const Ray ray = Ray(
		payload.pos, 0,
		payload.dir, 0
	);

	uint64_t hitRays = ballotARB(traceOcclusion(ray, payload.maxDist));

	//Store rays for the first thread in this warp
	//Assume 32 (NV) or 64 (AMD)

	if(gl_SubGroupInvocationARB == 0) {

		uint shadowDiv32 = shadowId >> 5;

		if(gl_SubGroupSizeARB == 32)
			shadowOutput[shadowDiv32] = uint(hitRays);

		else {
			uint shadowDiv32x2 = shadowDiv32 << 1;
			shadowOutput[shadowDiv32x2 | 1] = uint(hitRays >> 32);
			shadowOutput[shadowDiv32x2]		= uint(hitRays);
		}
	}
}