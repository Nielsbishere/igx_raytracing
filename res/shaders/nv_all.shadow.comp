#version 450
#extension GL_GOOGLE_include_directive : require
#extension GL_ARB_shader_ballot : require
#extension GL_ARB_gpu_shader_int64 : require
#include "defines.glsl"
#include "light.glsl"

layout(binding=2, std140) uniform ShadowProperties {
	uint totalSamples;
};

#ifdef VENDOR_NV

	layout(binding=7, std430) writeonly buffer ShadowOutput32 {
	    uint shadowOutput32[];
	};
	
	const uvec2 shift = uvec2(4, 1);			//log2(threads)
	const uvec2 mask = uvec2(15, 1);			//threads - 1

#else

	layout(binding=7, std430) writeonly buffer ShadowOutput64 {
	    uint64_t shadowOutput64[];
	};

	const uvec2 shift = uvec2(4, 2);			//log2(threads)
	const uvec2 mask = uvec2(15, 3);			//threads - 1

#endif

layout(binding=3, std140) uniform SeedBuffer {
	Seed seed;
};

layout(binding=1) uniform sampler2D dirObject;

//Shadows render as the following:
//
//16x16 thread
//On NV: 8x 16x2 per group 
//On AMD: 4x 16x4 per group 
//
//These blocks are stored linearly in memory by this group id
//therefore: loc / (16, gl_SubGroupSizeARB / 16) = dispatchId
//			dispatchId.x + dispatchId.y * ceil(width / 16.f)

layout(local_size_x = THREADS_XY, local_size_y = THREADS_XY, local_size_z = 2) in;

void main() {

	//Check if out of bounds
	
	const uvec2 loc = gl_GlobalInvocationID.xy;
	const uint i = gl_GlobalInvocationID.z;

	if(loc.x >= camera.width || loc.y >= camera.height || i >= totalSamples)
		return;

	const uvec2 res = uvec2(camera.width, camera.height);

	//Compute grid dimensions

	vec2 uv = (vec2(loc) + 0.5) / vec2(camera.width, camera.height);

	const vec4 _dirObject = texture(dirObject, uv);
	const uint object = floatBitsToUint(_dirObject.w);

	if(ballotARB(object != noRayHit) == 0) {

		#ifdef DEBUG
		
			#ifdef VENDOR_NV
				shadowOutput32[indexToLight(loc, res, i, shift, mask)] = 0;
			#else
				shadowOutput64[indexToLight(loc, res, i, shift, mask)] = 0;
			#endif

		#endif

		return;
	}

	const vec3 hitPos = camera.eye + _dirObject.xyz;

	//Shoot rays for this warp
	
	uvec2 tilingSiz = uvec2(128, 128);
	uv = (vec2(loc) + rand(loc + vec2(seed.randomX, seed.randomY))) / vec2(tilingSiz);

	uv += hammersley(i, totalSamples);

	vec2 random = rand(uv);

	//TODO: Point lights

	uint lightId = 0; //uint(blueNoise.r * float(sceneInfo.lightCount));

	const Light light = lights[lightId];

	float brightness, dist;
	vec3 l = getDirToLight(light, hitPos, brightness, dist, random);
	
	const Ray ray = Ray(hitPos, -l);

	bool hit = false;

	if(object != noRayHit) {

		//Trace sphere lights
		
		if(dist >= 0) {
		
			const vec2 radOrigin = unpackHalf2x16(light.radOrigin);
		
			//The part between the origin and radius needs rays to be traced

			if(dist >= radOrigin.y && dist < radOrigin.x)
				hit = traceOcclusion(ray, dist - radOrigin.y, object);
		
		}
		
		//Trace directional
		
		else hit = traceOcclusion(ray, noHit, object);
	}

	uint64_t hitRays = ballotARB(hit);

	//Store rays for the first thread in this warp
	//Assume 32 (NV) or 64 (AMD)

	if(gl_SubGroupInvocationARB == 0) {

		//If THREADS_XY changes, this has to as well
		
		#ifdef VENDOR_NV
			shadowOutput32[indexToLight(loc, res, i, shift, mask)] = uint(hitRays);
		#else
			shadowOutput64[indexToLight(loc, res, i, shift, mask)] = hitRays;
		#endif
	}
}