#version 450
#extension GL_GOOGLE_include_directive : require
#include "defines.glsl"
#include "trace.glsl"
#include "light.glsl"

layout(binding=0, outputFormat) uniform image2D rayOutput;
layout(binding=1, rgba32f) uniform image2D accumulationBuffer;
layout(binding=2, outputFormat) uniform image2D reflectionOutput;

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding=7, std140) readonly buffer Lights {
	Light lights[];
};

struct Position { vec3 pos; uint shadowStart; };

layout(binding=8, std140) readonly buffer PositionBuffer {
	Position positions[];
};

layout(binding=5, std140) readonly buffer Counters {
	uint shadowCounter;
	uint reflrectionCounter;
};

layout(binding=11, std140) readonly buffer ShadowOutput {
	uint shadowOutput[];
};

layout(binding=12, std140) readonly buffer ShadowColors {
	uvec2 shadowColors[];
};

float isShadowed(uint id) {
	return float((shadowOutput[id >> 5] & (1 << id)) == 0);
}

//Handling intersection

void main() {

	//Get ray position

	const ivec2 loc = ivec2(gl_GlobalInvocationID.xy);

	if(loc.x >= width || loc.y >= height) return;

	//Store

	vec3 diffuse = imageLoad(rayOutput, loc).rgb;
	diffuse += imageLoad(reflectionOutput, loc).rgb;

	const uint loc1D = loc.x + loc.y * width;
	const uint shadowStart = positions[loc1D].shadowStart;

	if(shadowStart != noRayHit)
		for(uint i = 0; i < lights.length(); ++i) {

			uint rayId = shadowStart + i;

			uvec2 col16 = shadowColors[rayId];
			vec3 col = vec3(unpackHalf2x16(col16.x), unpackHalf2x16(col16.y).x);

			diffuse += col * isShadowed(rayId);
		}

	//Increment accumulationBuffer

	vec4 accum = sampleCount == 1 ? vec4(0) : imageLoad(accumulationBuffer, loc);

	accum += vec4(diffuse, 0);

	imageStore(accumulationBuffer, loc, accum);

	vec3 color = accum.rgb / sampleCount;

	//Exposure mapping

	//if(any(isnan(color)))				//TODO: Why is diffuse NaN? invalid data in rayOutput or shadowRays?
	//	color = vec3(0, 0, 0);

	color = vec3(1, 1, 1) - exp(-color * exposure);

	//Gamma correction

	color = 
			color * 0.012522878 +
            color * color * 0.682171111 +
            color * color * color * 0.305306011;

	imageStore(rayOutput, loc, vec4(color, 1));
}