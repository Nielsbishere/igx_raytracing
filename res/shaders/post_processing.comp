#version 450
#extension GL_GOOGLE_include_directive : require
#include "defines.glsl"
#include "trace.glsl"
#include "light.glsl"

layout(binding=0, outputFormat) uniform image2D rayOutput;
layout(binding=1, rgba32f) uniform image2D accumulationBuffer;
layout(binding=2, outputFormat) uniform image2D reflectionOutput;

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding=7, std140) readonly buffer Lights {
	Light lights[];
};

struct Position { vec3 pos; uint shadowStart; };

layout(binding=8, std140) readonly buffer PositionBuffer {
	Position positions[];
};

layout(binding=5, std140) readonly buffer Counters {
	uint shadowCounter;
	uint reflrectionCounter;
};

layout(binding=4, std140) readonly buffer ShadowRays {
	RayPayload shadowRays[];
};

//Handling intersection

void main() {

	//Get ray position

	const ivec2 loc = ivec2(gl_GlobalInvocationID.xy);

	if(loc.x >= width || loc.y >= height) return;

	//Store

	vec3 diffuse = imageLoad(rayOutput, loc).rgb;
	diffuse += imageLoad(reflectionOutput, loc).rgb;

	const uint loc1D = loc.x + loc.y * width;
	const uint shadowStart = positions[loc1D].shadowStart;

	if(shadowStart != noRayHit)
		for(uint i = 0; i < lights.length(); ++i) {
			const RayPayload shadowRay = shadowRays[shadowStart + i];
			diffuse += shadowRay.color * float(shadowRay.loc1D == 0);
		}

	//Increment accumulationBuffer

	vec4 accum = sampleCount == 1 ? vec4(0) : imageLoad(accumulationBuffer, loc);

	accum += vec4(diffuse, 0);

	imageStore(accumulationBuffer, loc, accum);

	vec3 color = accum.rgb / sampleCount;

	//Exposure mapping

	//if(any(isnan(color)))				//TODO: Why is diffuse NaN? invalid data in rayOutput or shadowRays?
	//	color = vec3(0, 0, 0);

	color = vec3(1, 1, 1) - exp(-color * exposure);

	//Gamma correction

	color = 
			color * 0.012522878 +
            color * color * 0.682171111 +
            color * color * color * 0.305306011;

	imageStore(rayOutput, loc, vec4(color, 1));
}