#version 450
#extension GL_GOOGLE_include_directive : require
#include "defines.glsl"
#include "trace.glsl"
#include "material.glsl"
#include "light.glsl"

//TODO: Instead of having a layered image, vec4f16 OpenGL extension can be used
//		this can only be used in OpenGL tho, so two different binaries should be supplied

const vec3 skyboxColor = vec3(0, 0.5, 1);

layout(binding=0, std140) uniform GPUData {

	vec4 eye;
	vec4 p0;
	vec4 p1;
	vec4 p2;

	vec3 lightDir;
	float exposure;
};

layout(binding=0, outputFormat) writeonly uniform image2DArray rayOutput;

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding=3, std140) readonly buffer Materials {
	Material materials[];
};

layout(binding=4, std430) writeonly buffer ShadowRays {
	RayPayload shadowRays[];
};

layout(binding=5, std430) buffer Counters {
	uint shadowCounter;
	uint reflrectionCounter;
};

layout(binding=7, std430) readonly buffer Lights {
	Light lights[];
};

layout(binding=8, std140) writeonly buffer PositionBuffer {
	vec3 positions[];
};

//TODO: Lights can also have textures 

//Per light shading

vec3 shadeLight(
	const vec3 F0,
	const Material m,
	const Light light, 
	const vec3 pos,
	const vec3 n,
	const vec3 v,
	const uvec2 screenPos,
	inout uint id,
	const uint maxLayers,
	const float ao,
	const float NdotV
) {

	vec3 l = light.dir;
	float dist = 1;
	float maxDist = noHit;

	if(light.type == LightType_Point) {

		const vec3 L = pos - light.pos;
		const float dst = length(L);
		dist = dst / light.rad;

		//If it's out of range, don't bother with shadow rays

		if(dist > 1)
			return vec3(0, 0, 0);

		dist = 1 - dist;

		//Calculate params for point light shadows

		l = L * (1 / dst);
		maxDist = light.rad;
	}

	//Calculate color

	float k = m.roughness + 1;
	k *= k / 8;

	const vec3 color = cookTorrance(F0, m.albedo, light, n, l, v, NdotV, dist, m.roughness, m.metallic, k) * ao;

	//Only shoot shadows for materials that allow it 

	if((m.materialInfo & MaterialInfo_NoCastShadows) == 0) {
	
		const uint shadowId = atomicAdd(shadowCounter, 1);

		//If out of bounds, assume unshadowed

		if(shadowId >= shadowRays.length() || id >= maxLayers)
			return color;
	
		//Shoot shadow ray

		shadowRays[shadowId] = RayPayload(
			compressNormal(-l),
			screenPos.x << 16 | screenPos.y,
			/*0 << 16 | */ id,
			color,
			maxDist
		);

		++id;
	
		return vec3(0, 0, 0);
	}

	//By default don't do shadows

	return color;
}

//Trace reflection ray

vec3 traceReflection(const vec3 n, const vec3 v, const uvec2 screenPos, const float NdotV, const vec3 kS) {

	//const vec3 r = reflect(v, n);

	return kS * skyboxColor;
}

//Per pixel shading

vec3 shade(
	const Material m,
	const vec3 pos,
	const vec3 n, 
	const uvec2 screenPos,
	const uint maxLayers
) {
	const float ao = 1;				//TODO:

	const vec3 v = normalize(pos - eye.xyz);
	const float NdotV = max(dot(n, v), 0);

	const vec3 F0 = mix(vec3(0.04), m.albedo, m.metallic);

	const vec3 kS = fresnelSchlickRoughness(F0, NdotV, m.metallic, m.albedo, m.roughness);
	const vec3 kD = (1 - kS) * (1 - m.metallic);

	vec3 lighting = vec3(0, 0, 0);
	uint id = 0;

	//TODO: Perfect mirrors don't need shadow rays

	for(uint i = 0; i < lights.length(); ++i)
		lighting += shadeLight(F0, m, lights[i], pos, -n, v, screenPos, id, maxLayers, ao, NdotV);

	vec3 reflection = doReflection(-n, v, screenPos, NdotV, kS);

	return (m.ambient + kD / pi) * ao * m.albedo + reflection + lighting + m.emissive;
}

//Handling intersection

vec3 onMiss(const Ray r) {
	return skyboxColor;
}

vec3 onHit(const vec4 pos, const vec3 hit, const vec3 normal, const uint material, const uvec2 screenPos, const uint maxLayers) {
	return shade(materials[material], pos.xyz, normal, screenPos, maxLayers);
}

//Calculating intersection

vec3 doIntersect(const Ray r, const vec3 hit, const vec3 normal, const uint material, const uvec2 screenPos, inout vec3 outPos, const uint maxLayers) {

	if(hit.z == noHit)
		return onMiss(r);

	const vec4 position = r.pos + r.dir * hit.z;
	outPos = position.xyz + normal * epsilon;

	return onHit(position, hit, normal, material, screenPos, maxLayers);
}

vec3 trace(const Ray ray, const uvec2 screenPos, inout vec3 position, const uint maxLayers) {

	//TODO: Perhaps do an intersect per tile (4 planes)
	//		then intersect that geometry; not all spheres

	vec3 hit = vec3(0, 0, noHit);
	vec3 normal;
	uint material;

	traceGeometry(ray, hit, normal, material);

	//TODO: Only get normal of one object

	return doIntersect(ray, hit, normal, material, screenPos, position, maxLayers);
}

//

void main() {

	//Get ray position
	
	const uvec3 size = uvec3(imageSize(rayOutput));
	const uvec2 loc = gl_GlobalInvocationID.xy;

	if(loc.x >= size.x || loc.y >= size.y) return;

	//Shoot ray

	const vec4 right = p1 - p0;
	const vec4 up = p2 - p0;
	
	const vec2 uv = (vec2(loc) + 0.5) / vec2(size.xy);
	const vec4 rayPos = p0 + uv.x * right + uv.y * up;

	const Ray ray = Ray(
		rayPos,
		normalize(rayPos - eye)
	);

	vec3 pos = vec3(noHit, noHit, noHit);
	vec3 color = trace(ray, loc, pos, size.z);

	//Store

	positions[to1D(loc, size.xy)] = pos;
	imageStore(rayOutput, ivec3(loc, 0), vec4(color, 0));
}