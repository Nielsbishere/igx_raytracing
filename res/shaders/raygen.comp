#version 450
#extension GL_GOOGLE_include_directive : require
#include "defines.glsl"
#include "trace.glsl"
#include "material.glsl"
#include "light.glsl"

const vec3 skyboxColor = vec3(0, 0.5, 1);

layout(binding=0, std140) uniform GPUData {

	vec4 eye;
	vec4 p0;
	vec4 p1;
	vec4 p2;

	vec3 lightDir;
	float exposure;
};

layout(binding=0, outputFormat) writeonly uniform image2DArray rayOutput;

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding=3, std140) readonly buffer Materials {
	Material materials[];
};

layout(binding=4, std430) writeonly buffer ShadowRays {
	RayPayload shadowRays[];
};

layout(binding=5, std430) buffer Counters {
	uint shadowCounter;
	uint reflrectionCounter;
};

layout(binding=7, std430) readonly buffer Lights {
	Light lights[];
};

layout(binding=8, std140) writeonly buffer PositionBuffer {
	vec3 positions[];
};

//TODO: Lights can also have textures 

//Shading

vec3 shadeLight(
	const Material m, const Light light, 
	const vec3 pos, const vec3 n,
	const uvec2 screenPos, inout uint id, const uint maxLayers
) {

	vec3 l = light.dir;
	float dist = 1;
	float maxDist = noHit;

	if(light.type == LightType_Point) {

		const vec3 L = pos - light.pos;
		const float dst = length(L);
		dist = dst / light.rad;

		//If it's out of range, don't bother with shadow rays

		if(dist > 1)
			return vec3(0, 0, 0);

		dist = 1 - dist;

		//Calculate params for point light shadows

		l = L * (1 / dst);
		maxDist = light.rad;
	}

	//Calculate color

	float k = m.roughness + 1;
	k *= k / 8;

	const vec3 v = normalize(pos - eye.xyz);

	const vec3 specular = skyboxColor;

	const vec3 color = cookTorrance(m.albedo, light, n, l, v, dist, m.roughness, m.metallic, k, specular);

	//Only shoot shadows for materials that allow it 

	if((m.materialInfo & MaterialInfo_NoCastShadows) == 0) {
	
		const uint shadowId = atomicAdd(shadowCounter, 1);

		//If out of bounds, assume unshadowed

		if(shadowId >= shadowRays.length() || id >= maxLayers)
			return color;
	
		//Shoot shadow ray

		shadowRays[shadowId] = RayPayload(
			compressNormal(-l),
			screenPos.x << 16 | screenPos.y,
			/*0 << 16 | */ id,
			color,
			maxDist
		);

		++id;
	
		return vec3(0, 0, 0);
	}

	//By default don't do shadows

	return color;
}

vec3 shade(
	const Material m, const vec3 pos, const vec3 n, 
	const uvec2 screenPos, const uint maxLayers
) {
	const float ao = 1;				//TODO:
	vec3 col = m.ambient * ao;

	uint id = 0;

	for(uint i = 0; i < lights.length(); ++i)
		col += shadeLight(m, lights[i], pos, -n, screenPos, id, maxLayers);

	return col;
}

//Handling intersection

vec3 onMiss(const Ray r) {
	return skyboxColor;
}

vec3 onHit(const vec4 pos, const vec3 hit, const vec3 normal, const uint material, const uvec2 screenPos, const uint maxLayers) {
	return shade(materials[material], pos.xyz, normal, screenPos, maxLayers);
}

//Calculating intersection

vec3 doIntersect(const Ray r, const vec3 hit, const vec3 normal, const uint material, const uvec2 screenPos, inout vec3 outPos, const uint maxLayers) {

	if(hit.z == noHit)
		return onMiss(r);

	const vec4 position = r.pos + r.dir * hit.z;
	outPos = position.xyz + normal * epsilon;

	return onHit(position, hit, normal, material, screenPos, maxLayers);
}

vec3 trace(const Ray ray, const uvec2 screenPos, inout vec3 position, const uint maxLayers) {

	//TODO: Perhaps do an intersect per tile (4 planes)
	//		then intersect that geometry; not all spheres

	vec3 hit = vec3(0, 0, noHit);
	vec3 normal;
	uint material;

	traceGeometry(ray, hit, normal, material);

	//TODO: Only get normal of one object

	return doIntersect(ray, hit, normal, material, screenPos, position, maxLayers);
}

//

void main() {

	//Get ray position
	
	const uvec3 size = uvec3(imageSize(rayOutput));
	const uvec2 loc = gl_GlobalInvocationID.xy;

	if(loc.x >= size.x || loc.y >= size.y) return;

	//Shoot ray

	const vec4 right = p1 - p0;
	const vec4 up = p2 - p0;
	
	const vec2 uv = (vec2(loc) + 0.5) / vec2(size.xy);
	const vec4 rayPos = p0 + uv.x * right + uv.y * up;

	const Ray ray = Ray(
		rayPos,
		normalize(rayPos - eye)
	);

	vec3 pos = vec3(noHit, noHit, noHit);
	vec3 color = trace(ray, loc, pos, size.z);

	//Store

	positions[to1D(loc, size.xy)] = pos;
	imageStore(rayOutput, ivec3(loc, 0), vec4(color, 0));
}