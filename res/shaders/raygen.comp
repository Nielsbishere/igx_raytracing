#version 450
#extension GL_GOOGLE_include_directive : require
#include "primitive.glsl"
#include "material.glsl"

#define ALLOW_SPHERES
#define ALLOW_PLANES
#define ALLOW_TRIANGLES

layout(binding=0, std140) uniform RaygenData {
	vec4 eye;
	vec4 p0;
	vec4 p1;
	vec4 p2;
};

layout(binding=0, rgba16f) uniform image2D rayOutput;

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding=0, std140) buffer Spheres {
	vec4 spheres[];		//pos, rad^2
};

layout(binding=1, std140) buffer Materials {
	Material materials[];
};

layout(binding=2, std140) buffer Planes {
	vec4 planes[];		//dir, offset
};

layout(binding=3, std140) buffer Triangles {
	Triangle triangles[];
};

//TODO: Lights can also have textures 

//Shading

vec3 shadeLight(const Material m, const vec3 l, const vec3 pos, const vec3 n) {

	float shadow = 0;

	if((m.materialInfo & MaterialInfo_CastShadows) != 0)
		;	//TODO: cast shadow ray 

	float ndotl = dot(n, l);

	return m.ambientIor.xyz + m.colorSpecular.xyz * (1 - shadow) * ndotl;
}

vec3 shade(const Material m, const vec3 pos, const vec3 n) {
	return shadeLight(m, vec3(1, 1, -1), pos, -n);
}

//Handling intersection

vec3 onMiss(const Ray r) {
	return vec3(0, 0.5, 1);
}

vec3 onHit(const vec4 pos, const vec3 hit, const vec3 normal, const uint material) {
	return shade(materials[material], pos.xyz, normal);
}

vec3 doIntersect(const Ray r, const vec3 hit, const vec3 normal, const uint material) {

	if(hit.z == noHit)
		return onMiss(r);

	const vec4 position = r.pos + r.dir * hit.z;
	return onHit(position, hit, normal, material);
}

vec3 trace(const Ray ray) {

	vec3 hit = vec3(0, 0, noHit);
	vec3 normal;
	uint material;

	//TODO: Perhaps do an intersect per tile (4 planes)
	//		then intersect that geometry; not all spheres

	#ifdef ALLOW_SPHERES

	for(int i = 0; i < spheres.length(); ++i) {
		if(rayIntersectSphere(ray, spheres[i], hit)) {
			material = i;
			normal = normalize(hit.z * ray.dir.xyz + ray.pos.xyz - spheres[i].xyz);
		}
	}

	#endif 

	#ifdef ALLOW_PLANES

	for(int i = 0; i < planes.length(); ++i) {
		if(rayIntersectPlane(ray, planes[i], hit)) {
			material = i;
			normal = -planes[i].xyz;
		}
	}

	#endif

	#ifdef ALLOW_TRIANGLES

	for(int i = 0; i < triangles.length(); ++i) {
		if(rayIntersectTri(ray, triangles[i], hit)) {
			material = triangles[i].material;
			normal = -cross(triangles[i].p1 - triangles[i].p0, triangles[i].p2 - triangles[i].p0);	//Flat shading for now
		}
	}

	#endif

	//TODO: Only get normal of one object

	return doIntersect(ray, hit, normal, material);
}

//

void main() {

	//Get ray position

	const ivec2 size = imageSize(rayOutput);
	const uvec3 loc = gl_GlobalInvocationID;

	const vec2 uv = (vec2(loc.xy) + 0.5) / vec2(size);

	//Shoot ray

	const vec4 right = p1 - p0;
	const vec4 up = p2 - p0;

	const vec4 rayPos = p0 + uv.x * right + uv.y * up;

	const Ray ray = Ray(
		rayPos,
		normalize(rayPos - eye)
	);

	vec3 color = trace(ray);

	//Store

	imageStore(rayOutput, ivec2(loc.xy), vec4(color, 1));
}