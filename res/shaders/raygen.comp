#version 450
#extension GL_GOOGLE_include_directive : require
#include "defines.glsl"
#include "trace.glsl"
#include "material.glsl"
#include "light.glsl"

layout(binding=0, outputFormat) writeonly uniform image2D rayOutput;
layout(binding=2, outputFormat) writeonly uniform image2D reflectionOutput;

layout(local_size_x = THREADS_X, local_size_y = THREADS_Y, local_size_z = 1) in;

layout(binding=3, std140) readonly buffer Materials {
	Material materials[];
};

layout(binding=4, std140) writeonly buffer ShadowRays {
	ShadowPayload shadowRays[];
};

layout(binding=5, std140) buffer Counters {
	uint shadowCounter;
	uint reflrectionCounter;
};

layout(binding=7, std140) readonly buffer Lights {
	Light lights[];
};

struct Position { vec3 pos; uint shadowStart; };

layout(binding=8, std140) writeonly buffer PositionBuffer {
	Position positions[];
};

layout(binding=9, std140) writeonly buffer ReflectionRays {
	RayPayload reflectionRays[];
};

layout(binding=12, std140) writeonly buffer ShadowColors {
	uvec2 shadowColors[];
};

//TODO: Lights can also have textures 

//Per light shading

vec3 shadeLight(
	const vec3 F0,
	const Material m,
	const Light light, 
	const vec3 pos,
	const vec3 n,
	const vec3 v,
	const float ao,
	const float NdotV,
	const uint loc1D,
	const uint shadowId
) {

	vec3 l = light.dir;
	float invSquareDist = 1;
	float maxDist = noHit;

	if(light.type == LightType_Point) {

		l = pos - light.pos;
		const float dst = length(l);
		invSquareDist = max(1 - dst / light.rad, 0);		//TODO: This should be dst^2 (dot(l, l))

		//Calculate params for point light shadows

		maxDist = dst;				//TODO: This is along the direction of the light, it should be along the distance of the ray
	}

	l = normalize(l);

	//Calculate color

	float k = m.roughness + 1;
	k *= k / 8;
	
	const float NdotL = max(dot(n, l), 0);

	const vec3 color = cookTorrance(F0, m.albedo, light, n, l, v, NdotV, invSquareDist, m.roughness, m.metallic, k, NdotL) * ao;

	//Only shoot shadows for materials that allow it 

	#ifndef DISABLE_SHADOWS

		//Shoot shadow ray and assume unshadowed if out of bounds

		if(shadowId >= shadowRays.length())
			return color;

		shadowRays[shadowId] = ShadowPayload(
			pos,
			loc1D,
			-l,
			maxDist
		);

		shadowColors[shadowId] = uvec2(packHalf2x16(color.rg), packHalf2x16(color.bb));
		
		return vec3(0, 0, 0);

	#else
		return color;
	#endif
}

//Trace reflection ray

vec3 traceReflection(const vec3 n, const vec3 v, const float NdotV, const vec3 kS, const uint loc1D) {

	#ifndef DISABLE_REFLECTIONS

		if(kS.x > 0 && kS.y > 0 && kS.z > 0) {

			uint reflectionId = atomicAdd(reflrectionCounter, 1);

			reflectionRays[reflectionId] = RayPayload(
				reflect(v, n),
				loc1D,
				kS,
				noHit
			);

			return vec3(0, 0, 0);
		}

		return vec3(0, 0, 0);
	#else
		return kS * skyboxColor;
	#endif
}

//Per pixel shading

vec3 shade(
	const Material m,
	const vec3 pos,
	const vec3 n, 
	const vec3 v,
	const float NdotV,
	const uint loc1D
) {
	const float ao = 1;				//TODO:

	const vec3 F0 = mix(vec3(0.04), m.albedo, m.metallic);

	const vec3 kS = fresnelSchlickRoughness(F0, NdotV, m.metallic, m.albedo, m.roughness);
	const vec3 kD = (1 - kS) * (1 - m.metallic);

	vec3 lighting = vec3(0, 0, 0);

	uint shadowAtomicStart = 0;
	
	#ifndef DISABLE_SHADOWS
		shadowAtomicStart = atomicAdd(shadowCounter, lights.length());
	#endif
	
	positions[loc1D] = Position(pos + n * epsilon, shadowAtomicStart);

	//TODO: Perfect mirrors don't need shadow rays

	for(uint i = 0; i < lights.length(); ++i)
		lighting += shadeLight(F0, m, lights[i], pos, n, v, ao, NdotV, loc1D, shadowAtomicStart + i);

	vec3 reflection = traceReflection(n, v, NdotV, kS, loc1D);
	
	vec3 color = (m.ambient + kD / pi) * ao * m.albedo + reflection + lighting + m.emissive;
	return color;
}

//Handling intersection

vec3 doIntersect(const Ray r, const vec3 hit, const vec3 normal, const uint material, const uint loc1D) {

	if(hit.z == noHit) {
		positions[loc1D] = Position(vec3(0), noRayHit);
		imageStore(reflectionOutput, ivec2(loc1D % width, loc1D / width), vec4(0));
		return skyboxColor;
	}

	const vec3 position = r.pos + r.dir * hit.z;
	
	const vec3 v = normalize(position - eye);

	const float NdotV = max(dot(-normal, v), 0);
	
	vec3 color = shade(materials[material], position, normal, v, NdotV, loc1D);
	return color;
}

vec3 trace(const Ray ray, const uint loc1D) {

	//TODO: Perhaps do an intersect per tile (4 planes)
	//		then intersect that geometry; not all spheres

	vec3 hit = vec3(0, 0, noHit);
	vec3 normal;
	uint material;

	traceGeometry(ray, hit, normal, material);

	return doIntersect(ray, hit, normal, material, loc1D);
}

float rand1(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec2 rand(vec2 p) {
	return vec2(rand1(p), rand1(p * 29330 + 1020));
}

//

//#define USE_DOF

void main() {

	//Check if out of bounds
	
	const uvec2 loc = gl_GlobalInvocationID.xy;

	if(loc.x >= width || loc.y >= height)
		return;

	//Calculate center pixel

	vec2 centerPixel = (vec2(loc) + 0.5) * invRes;
	
	const vec3 right = p1 - p0;
	const vec3 up = p2 - p0;

	//Get focal point
		
	vec2 randomOffset = (rand(centerPixel + vec2(randomX, randomY)) - 0.5) * invRes;

	#ifdef USE_DOF

		const vec3 centerPixelPos = p0 + centerPixel.x * right + centerPixel.y * up;

		const vec3 dirToCenter = normalize(centerPixelPos - eye);

		const vec3 focalPoint = eye + dirToCenter * focalDistance; 
		
		randomOffset *= aperature;
		
		const vec2 rayPosUv = centerPixel + randomOffset;
		const vec3 rayPos = p0 + rayPosUv.x * right + rayPosUv.y * up;

	#else 

		centerPixel += randomOffset;
		const vec3 centerPixelPos = p0 + centerPixel.x * right + centerPixel.y * up;

		const vec3 dirToCenter = normalize(centerPixelPos - eye);
		
		const vec3 rayPos = eye;
		const vec3 focalPoint = centerPixelPos;

	#endif

	//Setup ray

	const Ray ray = Ray(
		rayPos, 0,
		normalize(focalPoint - rayPos), 0
	);
	
	const uint loc1D = loc.x + loc.y * width;

	//Store color

	const vec3 color = trace(ray, loc1D);

	imageStore(rayOutput, ivec2(loc), vec4(color, 0));
}