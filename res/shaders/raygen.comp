#version 450
#extension GL_GOOGLE_include_directive : require
#include "defines.glsl"
#include "trace.glsl"
#include "material.glsl"

layout(binding=0, std140) uniform RaygenData {
	vec4 eye;
	vec4 p0;
	vec4 p1;
	vec4 p2;
};

layout(binding=0, rgba16f) uniform image2D rayOutput;

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding=3, std140) buffer Materials {
	Material materials[];
};

layout(binding=4, std140) buffer ShadowRays {
	RayPayload shadowRays[];
};

layout(binding=5, std140) buffer Counters {
	uint shadowCounter;
	uint reflrectionCounter;
};

//TODO: Lights can also have textures 

//Shading

vec3 shadeLight(const Material m, const vec3 l, const vec3 pos, const vec3 n, const uvec2 screenPos) {

	float ndotl = clamp(dot(n, l), 0, 1);

	vec3 color = m.colorSpecular.xyz * ndotl;

	if((m.materialInfo & MaterialInfo_NoCastShadows) == 0) {

		uint shadowId = atomicAdd(shadowCounter, 1) % shadowRays.length();

		shadowRays[shadowId] = RayPayload(
			pos + n * epsilon,
			0,
			-l,
			screenPos.x,
			color,
			screenPos.y
		);

		return vec3(0, 0, 0);
	}

	return color;
}

vec3 shade(const Material m, const vec3 pos, const vec3 n, const uvec2 screenPos) {
	return m.ambientIor.xyz + shadeLight(m, vec3(0, 1, 0), pos, -n, screenPos);
}

//Handling intersection

vec3 onMiss(const Ray r) {
	return vec3(0, 0.5, 1);
}

vec3 onHit(const vec4 pos, const vec3 hit, const vec3 normal, const uint material, const uvec2 screenPos) {
	return shade(materials[material], pos.xyz, normal, screenPos);
}

//Calculating intersection

vec3 doIntersect(const Ray r, const vec3 hit, const vec3 normal, const uint material, const uvec2 screenPos) {

	if(hit.z == noHit)
		return onMiss(r);

	const vec4 position = r.pos + r.dir * hit.z;
	return onHit(position, hit, normal, material, screenPos);
}

vec3 trace(const Ray ray, const uvec2 screenPos) {

	//TODO: Perhaps do an intersect per tile (4 planes)
	//		then intersect that geometry; not all spheres

	vec3 hit = vec3(0, 0, noHit);
	vec3 normal;
	uint material;

	traceGeometry(ray, hit, normal, material);

	//TODO: Only get normal of one object

	return doIntersect(ray, hit, normal, material, screenPos);
}

//

void main() {

	//Get ray position

	const ivec2 size = imageSize(rayOutput);
	const uvec2 loc = gl_GlobalInvocationID.xy;

	const vec2 uv = (vec2(loc) + 0.5) / vec2(size);

	//Shoot ray

	const vec4 right = p1 - p0;
	const vec4 up = p2 - p0;

	const vec4 rayPos = p0 + uv.x * right + uv.y * up;

	const Ray ray = Ray(
		rayPos,
		normalize(rayPos - eye)
	);

	vec3 color = trace(ray, loc);

	//Store

	imageStore(rayOutput, ivec2(loc), vec4(color, 1));
}