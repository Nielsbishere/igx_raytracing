#version 450
#extension GL_GOOGLE_include_directive : require
#include "defines.glsl"
#include "trace.glsl"
#include "material.glsl"
#include "light.glsl"

layout(binding=0, std140) uniform GPUData {

	vec3 eye;
	float pad0;

	vec3 p0;
	float pad1;

	vec3 p1;
	float pad2;

	vec3 p2;
	float pad3;

	vec3 skyboxColor;
	float exposure;
};

layout(binding=0, outputFormat) writeonly uniform image2DArray rayOutput;

layout(local_size_x = THREADS_X, local_size_y = THREADS_Y, local_size_z = 1) in;

layout(binding=3, std140) readonly buffer Materials {
	Material materials[];
};

layout(binding=4, std140) writeonly buffer ShadowRays {
	RayPayload shadowRays[];
};

layout(binding=5, std140) buffer Counters {
	uint shadowCounter;
	uint reflrectionCounter;
};

layout(binding=7, std140) readonly buffer Lights {
	Light lights[];
};

layout(binding=8, std140) writeonly buffer PositionBuffer {
	vec3 positions[];
};

layout(binding=9, std140) writeonly buffer ReflectionRays {
	RayPayload reflectionRays[];
};

//TODO: Lights can also have textures 

//Per light shading

vec3 shadeLight(

	const vec3 F0,
	const Material m,
	const Light light, 

	const vec3 pos,
	const vec3 n,
	const vec3 v,
	const uvec2 screenPos,
	
	#if defined(AVOID_CONFLICTS)
		inout uint id,
	#endif

	const uint maxLayers,
	const float ao,
	const float NdotV
) {

	vec3 l = light.dir;
	float invSquareDist = 1;
	float maxDist = noHit;

	if(light.type == LightType_Point) {

		l = pos - light.pos;
		const float dst = length(l);
		invSquareDist = max(1 - dst / light.rad, 0);		//TODO: This should be dst^2

		//Calculate params for point light shadows

		maxDist = dst;				//TODO: This is along the direction of the light, it should be along the distance of the ray
	}

	l = normalize(l);

	//Calculate color

	float k = m.roughness + 1;
	k *= k / 8;
	
	const float NdotL = max(dot(n, l), 0);

	const vec3 color = cookTorrance(F0, m.albedo, light, n, l, v, NdotV, invSquareDist, m.roughness, m.metallic, k, NdotL) * ao;

	//Only shoot shadows for materials that allow it 

	#ifndef DISABLE_SHADOWS
		if((m.materialInfo & MaterialInfo_NoCastShadows) == 0) {
		
			#ifdef AVOID_CONFLICTS

				if(id >= maxLayers)
					return color;

			#endif

			const uint shadowId = atomicAdd(shadowCounter, 1);

			//If out of bounds, assume unshadowed

			if(shadowId >= shadowRays.length())
				return color;

			//Shoot shadow ray

			#if defined(AVOID_CONFLICTS)

				shadowRays[shadowId] = RayPayload(
					-l,
					screenPos.x << 16 | screenPos.y,
					uvec2(packHalf2x16(color.xy), packHalf2x16(vec2(0, color.z)) | id),
					maxDist
				);

				++id;

			#else

				shadowRays[shadowId] = RayPayload(
					-l,
					screenPos.x << 16 | screenPos.y,
					uvec2(packHalf2x16(color.xy), packHalf2x16(vec2(0, color.z))),
					maxDist
				);

			#endif
		
			return vec3(0, 0, 0);
		}
	#endif

	//By default don't do shadows

	return color;
}

//Trace reflection ray

vec3 traceReflection(const vec3 n, const vec3 v, const uvec2 screenPos, const uint width, const float NdotV, const vec3 kS) {

	#ifndef DISABLE_REFLECTIONS
		if(any(greaterThanEqual(kS, vec3(0, 0, 0)))) {

			uint reflectionId = atomicAdd(reflrectionCounter, 1);

			reflectionRays[reflectionId] = RayPayload(
				reflect(v, n),
				screenPos.x << 16 | screenPos.y,
				uvec2(packHalf2x16(kS.xy), packHalf2x16(vec2(0, kS.z))),
				noHit
			);

			return vec3(0, 0, 0);
		}
		else return vec3(0, 0, 0);
	#endif

	return kS * skyboxColor;
}

//Per pixel shading

vec3 shade(
	const Material m,
	const vec3 pos,
	const vec3 n, 
	const vec3 v,
	const float NdotV,
	const uvec2 screenPos,
	const uint maxLayers,
	const uint width
) {
	const float ao = 1;				//TODO:

	const vec3 F0 = mix(vec3(0.04), m.albedo, m.metallic);

	const vec3 kS = fresnelSchlickRoughness(F0, NdotV, m.metallic, m.albedo, m.roughness);
	const vec3 kD = (1 - kS) * (1 - m.metallic);

	vec3 lighting = vec3(0, 0, 0);
	
	#if defined(AVOID_CONFLICTS)
		uint id = 0;
	#endif

	//TODO: Perfect mirrors don't need shadow rays

	for(uint i = 0; i < lights.length(); ++i) {
	
		#if defined(AVOID_CONFLICTS)
			lighting += shadeLight(F0, m, lights[i], pos, n, v, screenPos, id, maxLayers, ao, NdotV);
		#else
			lighting += shadeLight(F0, m, lights[i], pos, n, v, screenPos, maxLayers, ao, NdotV);
		#endif
	}

	vec3 reflection = traceReflection(n, v, screenPos, width, NdotV, kS);

	return (m.ambient + kD / pi) * ao * m.albedo + reflection + lighting + m.emissive;
}

//Handling intersection

vec3 onMiss(const Ray r) {
	return skyboxColor;
}

vec3 onHit(const vec3 pos, const vec3 hit, const vec3 normal, const vec3 v, const float NdotV, const uint material, const uvec2 screenPos, const uint width, const uint maxLayers) {
	return shade(materials[material], pos, normal, v, NdotV, screenPos, width, maxLayers);
}

//Calculating intersection

vec3 doIntersect(const Ray r, const vec3 hit, const vec3 normal, const uint material, const uvec2 screenPos, inout vec3 outPos, const uint width, const uint maxLayers) {

	if(hit.z == noHit)
		return onMiss(r);

	const vec3 position = r.pos + r.dir * hit.z;
	outPos = position + normal * epsilon;
	
	const vec3 v = normalize(position - eye);
	const float NdotV = max(dot(-normal, v), 0);

	return onHit(position, hit, normal, v, NdotV, material, screenPos, width, maxLayers);
}

vec3 trace(const Ray ray, const uvec2 screenPos, inout vec3 position, const uint width, const uint maxLayers) {

	//TODO: Perhaps do an intersect per tile (4 planes)
	//		then intersect that geometry; not all spheres

	vec3 hit = vec3(0, 0, noHit);
	vec3 normal;
	uint material;

	traceGeometry(ray, hit, normal, material);

	//TODO: Only get normal of one object

	return doIntersect(ray, hit, normal, material, screenPos, position, width, maxLayers);
}

//

void main() {

	//Get ray position
	
	const uvec3 size = uvec3(imageSize(rayOutput));
	const uvec2 loc = gl_GlobalInvocationID.xy;

	if(loc.x >= size.x || loc.y >= size.y) return;

	//Shoot ray

	const vec3 right = p1 - p0;
	const vec3 up = p2 - p0;
	
	const vec2 uv = (vec2(loc) + 0.5) / vec2(size.xy);
	const vec3 rayPos = p0 + uv.x * right + uv.y * up;

	const Ray ray = Ray(
		rayPos, 0,
		normalize(rayPos - eye), 0
	);

	vec3 pos;
	const vec3 color = trace(ray, loc, pos, size.x, size.z);

	//Store

	const uint loc1D = loc.x + loc.y * size.x;
	positions[loc1D] = pos;

	imageStore(rayOutput, ivec3(loc, 0), vec4(color, 0));
}