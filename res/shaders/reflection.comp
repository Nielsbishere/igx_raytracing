#version 450
#extension GL_GOOGLE_include_directive : require
#include "defines.glsl"
#include "trace.glsl"
#include "material.glsl"
#include "light.glsl"

layout(binding=0, std140) uniform GPUData {

	vec3 eye;
	float pad0;

	vec3 p0;
	float pad1;

	vec3 p1;
	float pad2;

	vec3 p2;
	float pad3;

	vec3 skyboxColor;
	float exposure;
};

layout(binding=0, outputFormat) uniform image2DArray rayOutput;

layout(local_size_x = THREADS, local_size_y = 1, local_size_z = 1) in;

layout(binding=3, std140) readonly buffer Materials {
	Material materials[];
};

//TODO: Recursive shadows
//layout(binding=4, std140) writeonly buffer ShadowRays {
//	RayPayload shadowRays[];
//};

layout(binding=5, std140) readonly buffer Counters {
	uint shadowCounter;
	uint reflrectionCounter;
};

layout(binding=7, std140) readonly buffer Lights {
	Light lights[];
};

layout(binding=8, std140) readonly buffer PositionBuffer {
	vec3 positions[];
};

layout(binding=9, std140) readonly buffer ReflectionRays {
	RayPayload reflectionRays[];
};

//Per light shading

vec3 shadeLight(

	const vec3 F0,
	const Material m,
	const Light light, 

	const vec3 pos,
	const vec3 n,
	const vec3 v,
	const uvec2 screenPos,

	const uint maxLayers,
	const float ao,
	const float NdotV
) {

	vec3 l = light.dir;
	float invSquareDist = 1;
	float maxDist = noHit;

	if(light.type == LightType_Point) {

		l = pos - light.pos;
		const float dst = length(l);
		invSquareDist = max(1 - dst / light.rad, 0);		//TODO: This should be dst^2

		//Calculate params for point light shadows

		maxDist = dst;				//TODO: This is along the direction of the light, it should be along the distance of the ray
	}

	l = normalize(l);

	//Calculate color

	float k = m.roughness + 1;
	k *= k / 8;
	
	const float NdotL = max(dot(n, l), 0);

	const vec3 color = cookTorrance(F0, m.albedo, light, n, l, v, NdotV, invSquareDist, m.roughness, m.metallic, k, NdotL) * ao;
	return color;
}

//Trace reflection ray

vec3 traceReflection(const vec3 n, const vec3 v, const uvec2 screenPos, const uint width, const float NdotV, const vec3 kS) {
	return kS * skyboxColor;
}

//Per pixel shading

vec3 shade(
	const Material m,
	const vec3 pos,
	const vec3 n, 
	const vec3 v,
	const float NdotV,
	const uvec2 screenPos,
	const uint maxLayers,
	const uint width
) {
	const float ao = 1;				//TODO:

	const vec3 F0 = mix(vec3(0.04), m.albedo, m.metallic);

	const vec3 kS = fresnelSchlickRoughness(F0, NdotV, m.metallic, m.albedo, m.roughness);
	const vec3 kD = (1 - kS) * (1 - m.metallic);

	vec3 lighting = vec3(0, 0, 0);

	//TODO: Perfect mirrors don't need shadow rays

	for(uint i = 0; i < lights.length(); ++i)
			lighting += shadeLight(F0, m, lights[i], pos, n, v, screenPos, maxLayers, ao, NdotV);

	vec3 reflection = traceReflection(n, v, screenPos, width, NdotV, kS);

	return (m.ambient + kD / pi) * ao * m.albedo + reflection + lighting + m.emissive;
}

//Handling intersection

vec3 onMiss(const Ray r) {
	return skyboxColor;
}

vec3 onHit(const vec3 pos, const vec3 hit, const vec3 normal, const vec3 v, const float NdotV, const uint material, const uvec2 screenPos, const uint width, const uint maxLayers) {
	return shade(materials[material], pos, normal, v, NdotV, screenPos, width, maxLayers);
}

//Calculating intersection

vec3 doIntersect(const Ray r, const vec3 hit, const vec3 normal, const uint material, const uvec2 screenPos, inout vec3 outPos, const uint width, const uint maxLayers) {

	if(hit.z == noHit)
		return onMiss(r);

	const vec3 position = r.pos + r.dir * hit.z;
	outPos = position + normal * epsilon;
	
	const vec3 v = normalize(position - eye);
	const float NdotV = max(dot(-normal, v), 0);

	return onHit(position, hit, normal, v, NdotV, material, screenPos, width, maxLayers);
}

vec3 trace(const Ray ray, const uvec2 screenPos, inout vec3 position, const uint width, const uint maxLayers) {

	//TODO: Perhaps do an intersect per tile (4 planes)
	//		then intersect that geometry; not all spheres

	vec3 hit = vec3(0, 0, noHit);
	vec3 normal;
	uint material;

	traceGeometry(ray, hit, normal, material);

	//TODO: Only get normal of one object

	return doIntersect(ray, hit, normal, material, screenPos, position, width, maxLayers);
}

//


void main() {

	//Get ray position
	
	const uvec3 size = uvec3(imageSize(rayOutput));
	const uint reflectionId = gl_GlobalInvocationID.x;

	if(reflectionId >= reflrectionCounter) return;

	//Shoot ray
	
	const RayPayload payload = reflectionRays[reflectionId];

	const uvec2 loc = uvec2(payload.screenCoord >> 16, payload.screenCoord & 0xFFFF);

	//Shoot ray
	
	const uint loc1D = loc.x + loc.y * size.x;
	const Ray ray = Ray(
		positions[loc1D], 0,
		payload.dir, 0
	);

	vec3 hitPos = vec3(noHit);
	
	const vec3 color = vec3(unpackHalf2x16(payload.color.x), unpackHalf2x16(payload.color.y).y);

	vec4 result = imageLoad(rayOutput, ivec3(loc, 0));
	result += vec4(trace(ray, loc, hitPos, size.x, size.z) * color, 0);

	imageStore(rayOutput, ivec3(loc, 0), result);
}