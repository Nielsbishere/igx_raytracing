#version 450
#extension GL_GOOGLE_include_directive : require
#include "defines.glsl"
#include "trace.glsl"
#include "material.glsl"
#include "light.glsl"

layout(binding=0, std140) uniform GPUData {

	vec4 eye;
	vec4 p0;
	vec4 p1;
	vec4 p2;

	vec3 skyboxColor;
	float exposure;
};

layout(binding=0, outputFormat) uniform image2DArray rayOutput;

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(binding=3, std140) readonly buffer Materials {
	Material materials[];
};

//TODO: Recursive shadows
//layout(binding=4, std430) writeonly buffer ShadowRays {
//	RayPayload shadowRays[];
//};

layout(binding=5, std430) readonly buffer Counters {
	uint shadowCounter;
	uint reflrectionCounter;
};

layout(binding=7, std430) readonly buffer Lights {
	Light lights[];
};

layout(binding=8, std140) readonly buffer PositionBuffer {
	vec3 positions[];
};

layout(binding=9, std430) readonly buffer ReflectionRays {
	RayPayload reflectionRays[];
};

//Per light shading

vec3 shadeLight(

	const vec3 F0,
	const Material m,
	const Light light, 

	const vec3 pos,
	const vec3 n,
	const vec3 v,
	const uvec2 screenPos,

	const uint maxLayers,
	const float ao,
	const float NdotV
) {

	vec3 l = light.dir;
	float dist = 1;
	float maxDist = noHit;

	if(light.type == LightType_Point) {

		const vec3 L = pos - light.pos;
		const float dst = length(L);
		dist = dst / light.rad;

		//If it's out of range, don't bother with shadow rays

		if(dist > 1)
			return vec3(0, 0, 0);

		dist = 1 - dist;

		//Calculate params for point light shadows

		l = L * (1 / dst);
		maxDist = light.rad;
	}

	//Calculate color

	float k = m.roughness + 1;
	k *= k / 8;

	const vec3 color = cookTorrance(F0, m.albedo, light, n, l, v, NdotV, dist, m.roughness, m.metallic, k) * ao;

	//By default don't do shadows

	return color;
}

//Trace reflection ray

vec3 traceReflection(const vec3 n, const vec3 v, const uvec2 screenPos, const uint width, const float NdotV, const vec3 kS) {
	return kS * skyboxColor;
}

//Per pixel shading

vec3 shade(
	const Material m,
	const vec3 pos,
	const vec3 n, 
	const uvec2 screenPos,
	const uint maxLayers,
	const uint width
) {
	const float ao = 1;				//TODO:

	const vec3 v = normalize(pos - eye.xyz);

	const float NdotV = max(dot(n, v), 0);

	const vec3 F0 = mix(vec3(0.04), m.albedo, m.metallic);

	const vec3 kS = fresnelSchlickRoughness(F0, NdotV, m.metallic, m.albedo, m.roughness);
	const vec3 kD = (1 - kS) * (1 - m.metallic);

	vec3 lighting = vec3(0, 0, 0);
	
	for(uint i = 0; i < lights.length(); ++i)
		lighting += shadeLight(F0, m, lights[i], pos, -n, v, screenPos, maxLayers, ao, NdotV);

	vec3 reflection = traceReflection(-n, v, screenPos, width, NdotV, kS);

	return (m.ambient + kD / pi) * ao * m.albedo + reflection + lighting + m.emissive;
}

//Handling intersection

vec3 onMiss(const Ray r) {
	return skyboxColor;
}

vec3 onHit(const vec4 pos, const vec3 hit, const vec3 normal, const uint material, const uvec2 screenPos, const uint width, const uint maxLayers) {
	return shade(materials[material], pos.xyz, normal, screenPos, width, maxLayers);
}

//Calculating intersection

vec3 doIntersect(const Ray r, const vec3 hit, const vec3 normal, const uint material, const uvec2 screenPos, inout vec3 outPos, const uint width, const uint maxLayers) {

	if(hit.z == noHit)
		return onMiss(r);

	const vec4 position = r.pos + r.dir * hit.z;
	outPos = position.xyz + normal * epsilon;

	return onHit(position, hit, normal, material, screenPos, width, maxLayers);
}

vec3 trace(const Ray ray, const uvec2 screenPos, inout vec3 position, const uint width, const uint maxLayers) {

	//TODO: Acc struct 

	vec3 hit = vec3(0, 0, noHit);
	vec3 normal = vec3(0, 0, 0);
	uint material = 0;

	traceGeometry(ray, hit, normal, material);

	//TODO: Only get normal of one object

	return doIntersect(ray, hit, normal, material, screenPos, position, width, maxLayers);
}

//

void main() {

	//Get ray position
	
	const uvec3 size = uvec3(imageSize(rayOutput));
	const uint reflectionId = gl_GlobalInvocationID.x;

	if(reflectionId >= reflrectionCounter) return;

	//Shoot ray
	
	const RayPayload payload = reflectionRays[reflectionId];

	const uvec2 loc = uvec2(payload.screenCoord >> 16, payload.screenCoord & 0xFFFF);

	//Shoot ray

	const Ray ray = Ray(
		vec4(positions[to1D(loc, size.xy)], 1),
		vec4(decompressNormal(payload.dir), 1)
	);

	vec3 hitPos = vec3(noHit);

	vec4 result = imageLoad(rayOutput, ivec3(loc, 0));
	result += vec4(trace(ray, loc, hitPos, size.x, size.z) * payload.color, 0);

	imageStore(rayOutput, ivec3(loc, 0), result);
}