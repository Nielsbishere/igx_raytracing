#version 450
#extension GL_GOOGLE_include_directive : require
#extension GL_ARB_gpu_shader_int64 : require
#extension GL_ARB_shader_group_vote : require
#extension GL_ARB_shader_ballot : require
#include "defines.glsl"
#include "light.glsl"

layout(binding=0, outputFormat) writeonly uniform image2D lighting;

layout(binding=1) uniform sampler2D dirT;
layout(binding=2) uniform sampler2D uvObjectNormal;

layout(local_size_x = THREADS_XY, local_size_y = THREADS_XY, local_size_z = 1) in;

//Helper for subgroups
//
//Since we don't have subgroup khr (so no subgroupMin or subgroupMax)
//we need to use readInvocationARB and exchange data that way
//We basically do this:
//0.5, 0.75, 0.3, 0.2
//0.5, 0.2
//0.2
//But then with more threads (64 for AMD, 32 for NV)

#ifdef SUBGROUP_OPS

	float shaderGroupMin(float x, uint threadId, uint groupSize) {
		return subgroupMin(x);
	}

	float shaderGroupMax(float x, uint threadId, uint groupSize) {
		return subgroupMax(x);
	}

#else

uint bitCount(uint64_t v) {
	return bitCount(uint(v)) + bitCount(uint(v >> 32));
}

float shaderGroupMin(inout float x, uint threadId, uint groupSize) {
	
	uint localId = threadId % groupSize;

	x = min(x, readInvocationARB(x, localId + groupSize / 2));	//First 16NV or 32AMD
	x = min(x, readInvocationARB(x, localId + groupSize / 4));	//Then 8NV or 16AMD
	x = min(x, readInvocationARB(x, localId + groupSize / 8));	//Then 4NV or 8AMD
	x = min(x, readInvocationARB(x, localId + groupSize / 16));	//Then 2NV or 4AMD
	x = min(x, readInvocationARB(x, localId + groupSize / 32));	//Then 1NV or 2AMD

	//AMD Only, since it has twice the threads of NV

	if(groupSize == 64)
		x = min(x, readInvocationARB(x, localId + groupSize / 64));
		
	//First thread now has valid result 

	return readFirstInvocationARB(x);
}

float shaderGroupMax(inout float x, uint threadId, uint groupSize) {
	
	uint localId = threadId % groupSize;

	x = max(x, readInvocationARB(x, localId + groupSize / 2));	//First 16NV or 32AMD
	x = max(x, readInvocationARB(x, localId + groupSize / 4));	//Then 8NV or 16AMD
	x = max(x, readInvocationARB(x, localId + groupSize / 8));	//Then 4NV or 8AMD
	x = max(x, readInvocationARB(x, localId + groupSize / 16));	//Then 2NV or 4AMD
	x = max(x, readInvocationARB(x, localId + groupSize / 32));	//Then 1NV or 2AMD

	//AMD Only, since it has twice the threads of NV

	if(groupSize == 64)
		x = max(x, readInvocationARB(x, localId + groupSize / 64));
		
	//First thread now has valid result 

	return readFirstInvocationARB(x);
}

#endif

//

void main() {

	//TODO: Stereoscopic
	//TODO: Omnidirectional

	//Camera values

	const vec3 right = normalize(camera.p1 - camera.p0);
	const vec3 up = normalize(camera.p2 - camera.p0);
	const vec3 fwd = cross(right, up);

	//Initialize position dependent values
	
	const uvec2 loc = gl_GlobalInvocationID.xy;
	const vec2 uv = (vec2(loc) + 0.5) / vec2(camera.width, camera.height);
	
	//Fetch values only if in bounds
		
	Hit hit;
	hit.hitT = noHit;

	const bool inBounds = loc.x < camera.width && loc.y < camera.height;
	
	if(inBounds) {
		vec4 _dirT = texture(dirT, uv);
		hit.rayDir = _dirT.xyz;
		hit.hitT = _dirT.w;
	}

	//Only continue for non sky parts

	bool isSky = hit.hitT == noHit;

	if(allInvocationsARB(isSky)) {
		imageStore(lighting, ivec2(loc), vec4(0));
		return;
	}

	//Fetch texture stuff if needed 
	
	if(!isSky) {
		vec4 _uvObjectNormal = texture(uvObjectNormal, uv);
		hit.uv = _uvObjectNormal.xy;
		hit.object = floatBitsToUint(_uvObjectNormal.z);
		hit.normal = floatBitsToUint(_uvObjectNormal.w);
	}

	//Cull lights

	uint lightCounter = 0;
	uint lightIndices[LIGHTS_PER_TILE];
	
	//Cull directional lights per warp

	const vec3 n = decodeNormalLQ(hit.normal);

	uint localMask = 0;

	for(uint i = 0; i < sceneInfo.directionalLightCount; ++i) {
		
		Light l = lights[i];
		float NdotL = max(dot(n, decodeNormal(l.dir)), 0);

		//Mark as required if they affect the warp
		
		if(anyInvocationARB(!isSky && NdotL > 0) && lightCounter < LIGHTS_PER_TILE) {
			lightIndices[lightCounter] = i;
			lightCounter = min(lightCounter + 1, LIGHTS_PER_TILE);
		}
	}

	//Compute distance to camera
	
	vec3 relativePos = hit.rayDir * hit.hitT;
	float d = dot(relativePos, fwd);
	
	float minD = noHit, maxD = 0;

	if(!isSky) {
		minD = d;
		maxD = d;
	}
	
	//Compute min and max extent of this subgroup

	float minDepthf = shaderGroupMin(minD, gl_LocalInvocationIndex, gl_SubGroupSizeARB);
	float maxDepthf = shaderGroupMax(maxD, gl_LocalInvocationIndex, gl_SubGroupSizeARB);

	//Set up frustum

	const uint pixelPerLine = gl_SubGroupSizeARB / THREADS_XY;
	const uint lineId = gl_LocalInvocationIndex / gl_SubGroupSizeARB;

	const uvec2 tileOffsetBegin = loc + uvec2(0, pixelPerLine * lineId);
	const uvec2 tileOffsetEnd = min(tileOffsetBegin + uvec2(0, pixelPerLine), uvec2(camera.width, camera.height));

	const vec2 tileBeginUv = tileOffsetBegin / vec2(camera.width, camera.height);
	const vec2 tileEndUv = tileOffsetEnd / vec2(camera.width, camera.height);

	const bool isRight = false;				//Assume no VR (for now)

	Frustum frustum = calculateFrustum(tileBeginUv, tileEndUv, n, minDepthf, maxDepthf, isRight);
	
	//TODO: Point lights don't properly work 

	//Some threads might still be working on the dirLightMask, so we do some other work to minimize stalling
	//Cull lights per THREADS_XY * THREADS_XY
	//Each thread culls a different one

	//Example; THREADS_XY=2 (2x2 pixels per tile):
	//
	//0, 1,
	//2, 3
	//
	//4, 5,
	//6, 7

	for(
		uint i = gl_LocalInvocationIndex % gl_SubGroupSizeARB;
		i < sceneInfo.pointLightCount && lightCounter < LIGHTS_PER_TILE; 
		i += gl_SubGroupSizeARB
	) {

		uint j = sceneInfo.directionalLightCount + i;

		Light l = lights[j];
		vec4 sphere = vec4(l.pos - camera.eye, unpackHalf2x16(l.radOrigin).g);

		//Basically get a mask of the lights at that are on [0, gl_SubGroupSizeARB]
		//Then count how many of those lights are actually on
		//Then get the index of this light

		const bool isOn = sphereInsideFrustum(sphere, frustum);

		uint64_t v = ballotARB(isOn);
		uint localId = bitCount(v & gl_SubGroupLeMaskARB);
		uint lightId = lightCounter + localId;

		if(isOn && lightId < LIGHTS_PER_TILE)
			lightIndices[lightId] = j;

		lightCounter = min(lightCounter + bitCount(v), LIGHTS_PER_TILE);
	}

	vec4 color = vec4(0);

	//Unpack hit properties

	const vec3 v = hit.rayDir;
	const float NdotV = max(dot(v, -n), 0);
	
	Material m = materials[materialIndices[hit.object]];
	
	const float roughness = unpackColorAUnorm(m.ambientRoughness);
	const vec3 ambient = unpackColor3(m.ambientRoughness);

	const float metallic = unpackColorAUnorm(m.albedoMetallic);
	const vec3 albedo = unpackColor3(m.albedoMetallic);
	
	const vec3 F0 = mix(vec3(0.04), albedo, metallic);

	//Grab our lights from the point lights

	uint lightCount = min(lightCounter, LIGHTS_PER_TILE);

	for(uint i = 0; i < lightCount; ++i)
		if(!isSky)
			color.rgb += shadeLight(
				F0, albedo, roughness, metallic, 
				lights[lightIndices[i]], 
				relativePos + camera.eye, n, v, NdotV
			);

	//Write out
//	imageStore(lighting, ivec2(loc), vec4(lightCount / float(LIGHTS_PER_TILE)));
	imageStore(lighting, ivec2(loc), color);

}